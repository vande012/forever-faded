import path from 'path';
import koaStatic from 'koa-static';
import swaggerUi from 'swagger-ui-dist';
import fs from 'fs-extra';
import { produce } from 'immer';
import _ from 'lodash';
import * as pathToRegexp from 'path-to-regexp';
import bcrypt from 'bcryptjs';
import { validateYupSchema, yup } from '@strapi/utils';

const getService = (name, { strapi } = {
    strapi: global.strapi
})=>{
    return strapi.plugin('documentation').service(name);
};

// Add permissions
const RBAC_ACTIONS = [
    {
        section: 'plugins',
        displayName: 'Access the Documentation',
        uid: 'read',
        pluginName: 'documentation'
    },
    {
        section: 'plugins',
        displayName: 'Update and delete',
        uid: 'settings.update',
        pluginName: 'documentation'
    },
    {
        section: 'plugins',
        displayName: 'Regenerate',
        uid: 'settings.regenerate',
        pluginName: 'documentation'
    },
    {
        section: 'settings',
        displayName: 'Access the documentation settings page',
        uid: 'settings.read',
        pluginName: 'documentation',
        category: 'documentation'
    }
];
async function bootstrap({ strapi }) {
    await strapi.service('admin::permission').actionProvider.registerMany(RBAC_ACTIONS);
    const pluginStore = strapi.store({
        environment: '',
        type: 'plugin',
        name: 'documentation'
    });
    const config = await pluginStore.get({
        key: 'config'
    });
    if (!config) {
        pluginStore.set({
            key: 'config',
            value: {
                restrictedAccess: false
            }
        });
    }
    if (process.env.NODE_ENV !== 'production') {
        await getService('documentation').generateFullDoc();
    }
}

const addDocumentMiddlewares = async ({ strapi })=>{
    strapi.server.routes([
        {
            method: 'GET',
            path: '/plugins/documentation/(.*)',
            async handler (ctx, next) {
                ctx.url = path.basename(ctx.url);
                return koaStatic(swaggerUi.getAbsoluteFSPath(), {
                    maxage: 86400000,
                    defer: true
                })(ctx, next);
            },
            config: {
                auth: false
            }
        }
    ]);
};

async function register({ strapi }) {
    await addDocumentMiddlewares({
        strapi
    });
}

const pascalCase = (string)=>{
    return _.upperFirst(_.camelCase(string));
};

const params = [
    {
        name: 'sort',
        in: 'query',
        description: 'Sort by attributes ascending (asc) or descending (desc)',
        deprecated: false,
        required: false,
        schema: {
            type: 'string'
        }
    },
    {
        name: 'pagination[withCount]',
        in: 'query',
        description: 'Return page/pageSize (default: true)',
        deprecated: false,
        required: false,
        schema: {
            type: 'boolean'
        }
    },
    {
        name: 'pagination[page]',
        in: 'query',
        description: 'Page number (default: 0)',
        deprecated: false,
        required: false,
        schema: {
            type: 'integer'
        }
    },
    {
        name: 'pagination[pageSize]',
        in: 'query',
        description: 'Page size (default: 25)',
        deprecated: false,
        required: false,
        schema: {
            type: 'integer'
        }
    },
    {
        name: 'pagination[start]',
        in: 'query',
        description: 'Offset value (default: 0)',
        deprecated: false,
        required: false,
        schema: {
            type: 'integer'
        }
    },
    {
        name: 'pagination[limit]',
        in: 'query',
        description: 'Number of entities to return (default: 25)',
        deprecated: false,
        required: false,
        schema: {
            type: 'integer'
        }
    },
    {
        name: 'fields',
        in: 'query',
        description: 'Fields to return (ex: title,author)',
        deprecated: false,
        required: false,
        schema: {
            type: 'string'
        }
    },
    {
        name: 'populate',
        in: 'query',
        description: 'Relations to return',
        deprecated: false,
        required: false,
        schema: {
            type: 'string'
        }
    },
    {
        name: 'filters',
        in: 'query',
        description: 'Filters to apply',
        deprecated: false,
        required: false,
        schema: {
            type: 'object',
            additionalProperties: true
        },
        style: 'deepObject'
    },
    {
        name: 'locale',
        in: 'query',
        description: 'Locale to apply',
        deprecated: false,
        required: false,
        schema: {
            type: 'string'
        }
    }
];

/**
 * @description A reusable loop for building api endpoint paths and component schemas
 */ const loopContentTypeNames = (api, callback)=>{
    let result = {};
    for (const contentTypeName of api.ctNames){
        // Get the attributes found on the api's contentType
        const uid = `${api.getter}::${api.name}.${contentTypeName}`;
        const { attributes, info: contentTypeInfo, kind } = strapi.contentType(uid);
        // Get the routes for the current api
        const routeInfo = api.getter === 'plugin' ? strapi.plugin(api.name).routes['content-api'] : strapi.api(api.name).routes[contentTypeName];
        // Continue to next iteration if routeInfo is undefined
        if (!routeInfo) {
            continue;
        }
        // Uppercase the first letter of the api name
        const apiName = _.upperFirst(api.name);
        // Create a unique name if the api name and contentType name don't match
        const uniqueName = api.name === contentTypeName ? apiName : `${apiName} - ${_.upperFirst(contentTypeName)}`;
        const apiInfo = {
            ...api,
            routeInfo,
            attributes,
            uniqueName,
            contentTypeInfo,
            kind
        };
        result = {
            ...result,
            ...callback(apiInfo)
        };
    }
    return result;
};

/**
 * @description - Builds the Swagger response object for a given api
 */ const getApiResponse = ({ uniqueName, route, isListOfEntities = false })=>{
    const getSchema = ()=>{
        if (route.method === 'DELETE') {
            return {
                type: 'integer',
                format: 'int64'
            };
        }
        if (isListOfEntities) {
            return {
                $ref: `#/components/schemas/${pascalCase(uniqueName)}ListResponse`
            };
        }
        return {
            $ref: `#/components/schemas/${pascalCase(uniqueName)}Response`
        };
    };
    const schema = getSchema();
    return {
        200: {
            description: 'OK',
            content: {
                'application/json': {
                    schema
                }
            }
        },
        400: {
            description: 'Bad Request',
            content: {
                'application/json': {
                    schema: {
                        $ref: '#/components/schemas/Error'
                    }
                }
            }
        },
        401: {
            description: 'Unauthorized',
            content: {
                'application/json': {
                    schema: {
                        $ref: '#/components/schemas/Error'
                    }
                }
            }
        },
        403: {
            description: 'Forbidden',
            content: {
                'application/json': {
                    schema: {
                        $ref: '#/components/schemas/Error'
                    }
                }
            }
        },
        404: {
            description: 'Not Found',
            content: {
                'application/json': {
                    schema: {
                        $ref: '#/components/schemas/Error'
                    }
                }
            }
        },
        500: {
            description: 'Internal Server Error',
            content: {
                'application/json': {
                    schema: {
                        $ref: '#/components/schemas/Error'
                    }
                }
            }
        }
    };
};

const hasFindMethod = (handler)=>{
    if (typeof handler === 'string') {
        return handler.split('.').pop() === 'find';
    }
    return false;
};

/**
 * @description Parses a route with ':variable'
 *
 * @param {string} routePath - The route's path property
 * @returns {string}
 */ const parsePathWithVariables = (routePath)=>{
    const { tokens } = pathToRegexp.parse(routePath);
    return tokens.map((token)=>{
        switch(token.type){
            case 'text':
                return token.value;
            case 'param':
                return `{${token.name}}`;
            case 'wildcard':
                return `{${token.name}}`;
            case 'group':
                // Handle group tokens by mapping them within the same function context
                return `(${parsePathWithVariables(token.tokens.map((t)=>t).join(''))})`;
            default:
                throw new Error(`Unknown token type: ${token.type}`);
        }
    }).join('');
};
/**
 * @description Builds the required object for a path parameter
 *
 * @param {string} routePath - The route's path property
 *
 * @returns {object } Swagger path params object
 */ const getPathParams = (routePath)=>{
    const { tokens } = pathToRegexp.parse(routePath);
    return tokens.reduce((acc, param)=>{
        // Skip non-parameter tokens
        if (param.type !== 'param') {
            return acc;
        }
        acc.push({
            name: `${param.name}`,
            in: 'path',
            description: '',
            deprecated: false,
            required: true,
            schema: {
                type: 'number'
            }
        });
        return acc;
    }, []);
};
const getPathWithPrefix = (prefix, route)=>{
    // When the prefix is set on the routes and
    // the current route is not trying to remove it
    if (prefix && !_.has(route.config, 'prefix')) {
        // Add the prefix to the path
        return prefix.concat(route.path);
    }
    // Otherwise just return path
    return route.path;
};
/**
 * @description Gets all paths based on routes
 *
 * @param {object} apiInfo
 * @property {object} apiInfo.routeInfo - The api routes object
 * @property {string} apiInfo.uniqueName - Content type name | Api name + Content type name
 * @property {object} apiInfo.contentTypeInfo - The info object found on content type schemas
 *
 * @returns {object}
 */ const getPaths = ({ routeInfo, uniqueName, contentTypeInfo, kind })=>{
    // Get the routes for the current content type
    const contentTypeRoutes = routeInfo.routes.filter((route)=>{
        return route.path.includes(contentTypeInfo.pluralName) || route.path.includes(contentTypeInfo.singularName);
    });
    const paths = contentTypeRoutes.reduce((acc, route)=>{
        // TODO: Find a more reliable way to determine list of entities vs a single entity
        const isListOfEntities = hasFindMethod(route.handler);
        const methodVerb = route.method.toLowerCase();
        const hasPathParams = route.path.includes('/:');
        const pathWithPrefix = getPathWithPrefix(routeInfo.prefix, route);
        const routePath = hasPathParams ? parsePathWithVariables(pathWithPrefix) : pathWithPrefix;
        const responses = getApiResponse({
            uniqueName,
            route,
            isListOfEntities: kind !== 'singleType' && isListOfEntities
        });
        const swaggerConfig = {
            responses,
            tags: [
                _.upperFirst(uniqueName)
            ],
            parameters: [],
            operationId: `${methodVerb}${routePath}`
        };
        if (isListOfEntities) {
            swaggerConfig.parameters?.push(...params);
        }
        if (hasPathParams) {
            const pathParams = getPathParams(route.path);
            swaggerConfig.parameters?.push(...pathParams);
        }
        if ([
            'post',
            'put'
        ].includes(methodVerb)) {
            const refName = 'Request';
            const requestBody = {
                required: true,
                content: {
                    'application/json': {
                        schema: {
                            $ref: `#/components/schemas/${pascalCase(uniqueName)}${refName}`
                        }
                    }
                }
            };
            swaggerConfig.requestBody = requestBody;
        }
        _.set(acc, `${routePath}.${methodVerb}`, swaggerConfig);
        return acc;
    }, {});
    return paths;
};
/**
 * @description - Builds the Swagger paths object for each api
 */ const buildApiEndpointPath = (api)=>{
    // A reusable loop for building paths and component schemas
    // Uses the api param to build a new set of params for each content type
    // Passes these new params to the function provided
    return loopContentTypeNames(api, getPaths);
};

/**
 * @description Determines the format of the data response
 *
 * @param {boolean} isListOfEntities - Checks for a multiple entities
 * @param {object} attributes - The attributes found on a contentType

 * @returns object | array of attributes
 */ var getSchemaData = ((isListOfEntities, attributes)=>{
    if (isListOfEntities) {
        return {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: {
                        type: 'number'
                    },
                    documentId: {
                        type: 'string'
                    },
                    ...attributes
                }
            }
        };
    }
    return {
        type: 'object',
        properties: {
            id: {
                type: 'number'
            },
            documentId: {
                type: 'string'
            },
            ...attributes
        }
    };
});

/**
 * @description - Convert attribute component names to OpenAPI component names
 *
 * @returns OpenAPI component name
 */ const convertComponentName = (component, isRef = false)=>{
    const cleanComponentName = `${pascalCase(component)}Component`;
    if (isRef) {
        return `#/components/schemas/${cleanComponentName}`;
    }
    return cleanComponentName;
};
/**
 * @description - Converts types found on attributes to OpenAPI acceptable data types
 *
 * @returns Attributes using OpenAPI acceptable data types
 */ const cleanSchemaAttributes = (attributes, { typeMap = new Map(), isRequest = false, didAddStrapiComponentsToSchemas })=>{
    const schemaAttributes = {};
    for (const prop of Object.keys(attributes)){
        const attribute = attributes[prop];
        switch(attribute.type){
            case 'password':
                {
                    if (!isRequest) {
                        break;
                    }
                    schemaAttributes[prop] = {
                        type: 'string',
                        format: 'password',
                        example: '*******'
                    };
                    break;
                }
            case 'email':
                {
                    schemaAttributes[prop] = {
                        type: 'string',
                        format: 'email'
                    };
                    break;
                }
            case 'string':
            case 'text':
            case 'richtext':
                {
                    schemaAttributes[prop] = {
                        type: 'string'
                    };
                    break;
                }
            case 'timestamp':
                {
                    schemaAttributes[prop] = {
                        type: 'string',
                        format: 'timestamp',
                        example: Date.now()
                    };
                    break;
                }
            case 'time':
                {
                    schemaAttributes[prop] = {
                        type: 'string',
                        format: 'time',
                        example: '12:54.000'
                    };
                    break;
                }
            case 'date':
                {
                    schemaAttributes[prop] = {
                        type: 'string',
                        format: 'date'
                    };
                    break;
                }
            case 'datetime':
                {
                    schemaAttributes[prop] = {
                        type: 'string',
                        format: 'date-time'
                    };
                    break;
                }
            case 'boolean':
                {
                    schemaAttributes[prop] = {
                        type: 'boolean'
                    };
                    break;
                }
            case 'enumeration':
                {
                    schemaAttributes[prop] = {
                        type: 'string',
                        enum: [
                            ...attribute.enum
                        ]
                    };
                    break;
                }
            case 'decimal':
            case 'float':
                {
                    schemaAttributes[prop] = {
                        type: 'number',
                        format: 'float'
                    };
                    break;
                }
            case 'integer':
                {
                    schemaAttributes[prop] = {
                        type: 'integer'
                    };
                    break;
                }
            case 'biginteger':
                {
                    schemaAttributes[prop] = {
                        type: 'string',
                        pattern: '^\\d*$',
                        example: '123456789'
                    };
                    break;
                }
            case 'json':
            case 'blocks':
                {
                    schemaAttributes[prop] = {};
                    break;
                }
            case 'uid':
                {
                    schemaAttributes[prop] = {
                        type: 'string'
                    };
                    break;
                }
            case 'component':
                {
                    const componentAttributes = strapi.components[attribute.component].attributes;
                    const rawComponentSchema = {
                        type: 'object',
                        properties: {
                            ...isRequest ? {} : {
                                id: {
                                    type: 'number'
                                }
                            },
                            ...cleanSchemaAttributes(componentAttributes, {
                                typeMap,
                                isRequest,
                                didAddStrapiComponentsToSchemas
                            })
                        }
                    };
                    const refComponentSchema = {
                        $ref: convertComponentName(attribute.component, true)
                    };
                    const componentExists = didAddStrapiComponentsToSchemas(convertComponentName(attribute.component), rawComponentSchema);
                    const finalComponentSchema = componentExists ? refComponentSchema : rawComponentSchema;
                    if (attribute.repeatable) {
                        schemaAttributes[prop] = {
                            type: 'array',
                            items: finalComponentSchema
                        };
                    } else {
                        schemaAttributes[prop] = finalComponentSchema;
                    }
                    break;
                }
            case 'dynamiczone':
                {
                    const components = attribute.components.map((component)=>{
                        const componentAttributes = strapi.components[component].attributes;
                        const rawComponentSchema = {
                            type: 'object',
                            properties: {
                                ...isRequest ? {} : {
                                    id: {
                                        type: 'number'
                                    }
                                },
                                __component: {
                                    type: 'string',
                                    enum: [
                                        component
                                    ]
                                },
                                ...cleanSchemaAttributes(componentAttributes, {
                                    typeMap,
                                    isRequest,
                                    didAddStrapiComponentsToSchemas
                                })
                            }
                        };
                        const refComponentSchema = {
                            $ref: convertComponentName(component, true)
                        };
                        const componentExists = didAddStrapiComponentsToSchemas(convertComponentName(component), rawComponentSchema);
                        const finalComponentSchema = componentExists ? refComponentSchema : rawComponentSchema;
                        return finalComponentSchema;
                    });
                    let discriminator;
                    if (components.every((component)=>Object.hasOwn(component, '$ref'))) {
                        discriminator = {
                            propertyName: '__component',
                            mapping: attribute.components.reduce((acc, component)=>{
                                acc[component] = convertComponentName(component, true);
                                return acc;
                            }, {})
                        };
                    }
                    schemaAttributes[prop] = {
                        type: 'array',
                        items: {
                            anyOf: components
                        },
                        discriminator
                    };
                    break;
                }
            case 'media':
                {
                    const imageAttributes = strapi.contentType('plugin::upload.file').attributes;
                    const isListOfEntities = attribute.multiple ?? false;
                    if (isRequest) {
                        const oneOfType = {
                            oneOf: [
                                {
                                    type: 'integer'
                                },
                                {
                                    type: 'string'
                                }
                            ],
                            example: 'string or id'
                        };
                        schemaAttributes[prop] = isListOfEntities ? {
                            type: 'array',
                            items: oneOfType
                        } : oneOfType;
                        break;
                    }
                    schemaAttributes[prop] = getSchemaData(isListOfEntities, cleanSchemaAttributes(imageAttributes, {
                        typeMap,
                        didAddStrapiComponentsToSchemas
                    }));
                    break;
                }
            case 'relation':
                {
                    const isListOfEntities = attribute.relation.includes('ToMany');
                    if (isRequest) {
                        const oneOfType = {
                            oneOf: [
                                {
                                    type: 'integer'
                                },
                                {
                                    type: 'string'
                                }
                            ],
                            example: 'string or id'
                        };
                        schemaAttributes[prop] = isListOfEntities ? {
                            type: 'array',
                            items: oneOfType
                        } : oneOfType;
                        break;
                    }
                    if (!('target' in attribute) || !attribute.target || typeMap.has(attribute.target)) {
                        schemaAttributes[prop] = getSchemaData(isListOfEntities, {});
                        break;
                    }
                    typeMap.set(attribute.target, true);
                    const targetAttributes = strapi.contentType(attribute.target).attributes;
                    schemaAttributes[prop] = getSchemaData(isListOfEntities, cleanSchemaAttributes(targetAttributes, {
                        typeMap,
                        isRequest,
                        didAddStrapiComponentsToSchemas
                    }));
                    break;
                }
            default:
                {
                    // @ts-expect-error - This is a catch all for any other types
                    throw new Error(`Invalid type ${attribute.type} while generating open api schema.`);
                }
        }
    }
    return schemaAttributes;
};

const getRequiredAttributes = (allAttributes)=>{
    const requiredAttributes = [];
    for(const key in allAttributes){
        if (allAttributes[key].required) {
            requiredAttributes.push(key);
        }
    }
    return requiredAttributes;
};
/**
 * @description Get all open api schema objects for a given content type
 *
 * @param {object} apiInfo
 * @property {string} apiInfo.uniqueName - Api name | Api name + Content type name
 * @property {object} apiInfo.attributes - Attributes on content type
 * @property {object} apiInfo.routeInfo - The routes for the api
 *
 * @returns {object} Open API schemas
 */ const getAllSchemasForContentType = ({ routeInfo, attributes, uniqueName })=>{
    // Store response and request schemas in an object
    let strapiComponentSchemas = {};
    const schemas = {};
    const typeName = pascalCase(uniqueName);
    // adds a ComponentSchema to the Schemas so it can be used as Ref
    const didAddStrapiComponentsToSchemas = (schemaName, schema)=>{
        if (!Object.keys(schema) || !Object.keys(schema.properties)) return false;
        // Add the Strapi components to the schema
        strapiComponentSchemas = {
            ...strapiComponentSchemas,
            [schemaName]: schema
        };
        return true;
    };
    // Get all the route methods
    const routeMethods = routeInfo.routes.map((route)=>route.method);
    const attributesToOmit = [
        'createdAt',
        'updatedAt',
        'publishedAt',
        'publishedBy',
        'updatedBy',
        'createdBy'
    ];
    const attributesForRequest = _.omit(attributes, attributesToOmit);
    // Get a list of required attribute names
    const requiredRequestAttributes = getRequiredAttributes(attributesForRequest);
    // Build the request schemas when the route has POST or PUT methods
    if (routeMethods.includes('POST') || routeMethods.includes('PUT')) {
        // Build localization requests schemas
        // Build the request schema
        Object.assign(schemas, {
            [`${typeName}Request`]: {
                type: 'object',
                required: [
                    'data'
                ],
                properties: {
                    data: {
                        ...requiredRequestAttributes.length && {
                            required: requiredRequestAttributes
                        },
                        type: 'object',
                        properties: cleanSchemaAttributes(attributesForRequest, {
                            isRequest: true,
                            didAddStrapiComponentsToSchemas
                        })
                    }
                }
            }
        });
    }
    // Check for routes that need to return a list
    const hasListOfEntities = routeInfo.routes.filter((route)=>hasFindMethod(route.handler)).length;
    if (hasListOfEntities) {
        // Build the list response schema
        Object.assign(schemas, {
            [`${typeName}ListResponse`]: {
                type: 'object',
                properties: {
                    data: {
                        type: 'array',
                        items: {
                            $ref: `#/components/schemas/${typeName}`
                        }
                    },
                    meta: {
                        type: 'object',
                        properties: {
                            pagination: {
                                type: 'object',
                                properties: {
                                    page: {
                                        type: 'integer'
                                    },
                                    pageSize: {
                                        type: 'integer',
                                        minimum: 25
                                    },
                                    pageCount: {
                                        type: 'integer',
                                        maximum: 1
                                    },
                                    total: {
                                        type: 'integer'
                                    }
                                }
                            }
                        }
                    }
                }
            }
        });
    }
    const requiredAttributes = getRequiredAttributes(attributes);
    // Build the response schema
    Object.assign(schemas, {
        [`${typeName}`]: {
            type: 'object',
            ...requiredAttributes.length && {
                required: requiredAttributes
            },
            properties: {
                id: {
                    type: 'number'
                },
                documentId: {
                    type: 'string'
                },
                ...cleanSchemaAttributes(attributes, {
                    didAddStrapiComponentsToSchemas
                })
            }
        },
        [`${typeName}Response`]: {
            type: 'object',
            properties: {
                data: {
                    $ref: `#/components/schemas/${typeName}`
                },
                meta: {
                    type: 'object'
                }
            }
        }
    });
    return {
        ...schemas,
        ...strapiComponentSchemas
    };
};
const buildComponentSchema = (api)=>{
    // A reusable loop for building paths and component schemas
    // Uses the api param to build a new set of params for each content type
    // Passes these new params to the function provided
    return loopContentTypeNames(api, getAllSchemasForContentType);
};

const getPluginsThatNeedDocumentation = (config)=>{
    // Default plugins that need documentation generated
    const defaultPlugins = [
        'upload',
        'users-permissions'
    ];
    // User specified plugins that need documentation generated
    const userPluginsConfig = config['x-strapi-config'].plugins;
    if (userPluginsConfig === null) {
        // The user hasn't specified any plugins to document, use the defaults
        return defaultPlugins;
    }
    if (userPluginsConfig.length) {
        // The user has specified certain plugins to document, use them
        return userPluginsConfig;
    }
    // The user has specified that no plugins should be documented
    return [];
};

const createService$1 = ({ strapi })=>{
    const config = strapi.config.get('plugin::documentation');
    const pluginsThatNeedDocumentation = getPluginsThatNeedDocumentation(config);
    const overrideService = getService('override');
    return {
        getDocumentationVersion () {
            return config.info.version;
        },
        getFullDocumentationPath () {
            return path.join(strapi.dirs.app.extensions, 'documentation', 'documentation');
        },
        getDocumentationVersions () {
            return fs.readdirSync(this.getFullDocumentationPath()).map((version)=>{
                try {
                    const filePath = path.resolve(this.getFullDocumentationPath(), version, 'full_documentation.json');
                    const doc = JSON.parse(fs.readFileSync(filePath).toString());
                    const generatedDate = doc.info['x-generation-date'];
                    return {
                        version,
                        generatedDate,
                        url: ''
                    };
                } catch (err) {
                    return null;
                }
            }).filter((x)=>x);
        },
        /**
     * Returns settings stored in core-store
     */ async getDocumentationAccess () {
            const { restrictedAccess } = await strapi.store({
                environment: '',
                type: 'plugin',
                name: 'documentation',
                key: 'config'
            }).get();
            return {
                restrictedAccess
            };
        },
        getApiDocumentationPath (api) {
            if (api.getter === 'plugin') {
                return path.join(strapi.dirs.app.extensions, api.name, 'documentation');
            }
            return path.join(strapi.dirs.app.api, api.name, 'documentation');
        },
        async deleteDocumentation (version) {
            const apis = this.getPluginAndApiInfo();
            for (const api of apis){
                await fs.remove(path.join(this.getApiDocumentationPath(api), version));
            }
            await fs.remove(path.join(this.getFullDocumentationPath(), version));
        },
        getPluginAndApiInfo () {
            const pluginsToDocument = pluginsThatNeedDocumentation.map((plugin)=>{
                return {
                    name: plugin,
                    getter: 'plugin',
                    ctNames: Object.keys(strapi.plugin(plugin).contentTypes)
                };
            });
            const apisToDocument = Object.keys(strapi.apis).map((api)=>{
                return {
                    name: api,
                    getter: 'api',
                    ctNames: Object.keys(strapi.api(api).contentTypes)
                };
            });
            return [
                ...apisToDocument,
                ...pluginsToDocument
            ];
        },
        /**
     * @description - Creates the Swagger json files
     */ async generateFullDoc (versionOpt) {
            const version = versionOpt ?? this.getDocumentationVersion();
            const apis = this.getPluginAndApiInfo();
            const apisThatNeedGeneratedDocumentation = apis.filter(({ name })=>!overrideService.isEnabled(name));
            // Initialize the generated documentation with defaults
            const generatedDocumentation = await produce(config, async (draft)=>{
                if (draft.servers?.length === 0) {
                    // When no servers found set the defaults
                    const serverUrl = strapi.config.get('server.absoluteUrl');
                    const apiPath = strapi.config.get('api.rest.prefix');
                    draft.servers = [
                        {
                            url: `${serverUrl}${apiPath}`,
                            description: 'Development server'
                        }
                    ];
                }
                if (!draft.components) {
                    draft.components = {};
                }
                // Set the generated date
                draft.info['x-generation-date'] = new Date().toISOString();
                // Set the plugins that need documentation
                draft['x-strapi-config'].plugins = pluginsThatNeedDocumentation;
                // Delete the mutateDocumentation key from the config so it doesn't end up in the spec
                delete draft['x-strapi-config'].mutateDocumentation;
                // Generate the documentation for each api and update the generatedDocumentation
                for (const api of apisThatNeedGeneratedDocumentation){
                    const newApiPath = buildApiEndpointPath(api);
                    const generatedSchemas = buildComponentSchema(api);
                    if (generatedSchemas) {
                        draft.components.schemas = {
                            ...draft.components.schemas,
                            ...generatedSchemas
                        };
                    }
                    if (newApiPath) {
                        draft.paths = {
                            ...draft.paths,
                            ...newApiPath
                        };
                    }
                }
                // When overrides are present update the generatedDocumentation
                if (overrideService.registeredOverrides.length > 0) {
                    overrideService.registeredOverrides.forEach((override)=>{
                        // Only run the overrrides when no override version is provided,
                        // or when the generated documentation version matches the override version
                        if (!override?.info?.version || override.info.version === version) {
                            if (override.tags) {
                                // Merge override tags with the generated tags
                                draft.tags = draft.tags || [];
                                draft.tags.push(...override.tags);
                            }
                            if (override.paths) {
                                // Merge override paths with the generated paths
                                // The override will add a new path or replace the value of an existing path
                                draft.paths = {
                                    ...draft.paths,
                                    ...override.paths
                                };
                            }
                            if (override.components) {
                                const keys = Object.keys(override.components);
                                keys.forEach((overrideKey)=>{
                                    draft.components = draft.components || {};
                                    const overrideValue = override.components?.[overrideKey];
                                    const originalValue = draft.components?.[overrideKey];
                                    Object.assign(draft.components, {
                                        [overrideKey]: {
                                            ...originalValue,
                                            ...overrideValue
                                        }
                                    });
                                });
                            }
                        }
                    });
                }
            });
            // Escape hatch, allow the user to provide a mutateDocumentation function that can alter any part of
            // the generated documentation before it is written to the file system
            const userMutatesDocumentation = config['x-strapi-config'].mutateDocumentation;
            const finalDocumentation = userMutatesDocumentation ? produce(generatedDocumentation, userMutatesDocumentation) : generatedDocumentation;
            // Get the file path for the final documentation
            const fullDocJsonPath = path.join(this.getFullDocumentationPath(), version, 'full_documentation.json');
            // Write the documentation to the file system
            await fs.ensureFile(fullDocJsonPath);
            await fs.writeJson(fullDocJsonPath, finalDocumentation, {
                spaces: 2
            });
        }
    };
};

const createService = ({ strapi })=>{
    const registeredOverrides = [];
    const excludedFromGeneration = [];
    return {
        registeredOverrides,
        excludedFromGeneration,
        /**
     *
     * @param {(string | string[])} api - The name of the api or and array of apis to exclude from generation
     */ excludeFromGeneration (api) {
            if (Array.isArray(api)) {
                excludedFromGeneration.push(...api);
                return;
            }
            excludedFromGeneration.push(api);
        },
        isEnabled (name) {
            return excludedFromGeneration.includes(name);
        },
        registerOverride (override, opts) {
            const { pluginOrigin, excludeFromGeneration = [] } = opts ?? {};
            const pluginsThatNeedDocumentation = getPluginsThatNeedDocumentation(strapi.config.get('plugin::documentation'));
            // Don't apply the override if the plugin is not in the list of plugins that need documentation
            if (pluginOrigin && !pluginsThatNeedDocumentation.includes(pluginOrigin)) return;
            if (excludeFromGeneration.length) {
                this.excludeFromGeneration(excludeFromGeneration);
            }
            let overrideToRegister = override;
            // Parse yaml if we receive a string
            if (typeof override === 'string') {
                // eslint-disable-next-line @typescript-eslint/no-var-requires
                overrideToRegister = require('yaml').parse(overrideToRegister);
            }
            // receive an object we can register it directly
            registeredOverrides.push(overrideToRegister);
        }
    };
};

// import type { Common } from '@strapi/types';
var services = {
    documentation: createService$1,
    override: createService
};

var restrictAccess = (async (ctx, next)=>{
    const pluginStore = strapi.store({
        type: 'plugin',
        name: 'documentation'
    });
    const config = await pluginStore.get({
        key: 'config'
    });
    if (!config.restrictedAccess) {
        return next();
    }
    if (!ctx.session || !ctx.session.documentation || !ctx.session.documentation.logged) {
        const querystring = ctx.querystring ? `?${ctx.querystring}` : '';
        return ctx.redirect(`${strapi.config.server.url}/documentation/login${querystring}`);
    }
    // Execute the action.
    return next();
});

var routes = [
    {
        method: 'GET',
        path: '/',
        handler: 'documentation.index',
        config: {
            auth: false,
            middlewares: [
                restrictAccess
            ]
        }
    },
    {
        method: 'GET',
        path: '/v:major(\\d+).:minor(\\d+).:patch(\\d+)',
        handler: 'documentation.index',
        config: {
            auth: false,
            middlewares: [
                restrictAccess
            ]
        }
    },
    {
        method: 'GET',
        path: '/login',
        handler: 'documentation.loginView',
        config: {
            auth: false
        }
    },
    {
        method: 'POST',
        path: '/login',
        handler: 'documentation.login',
        config: {
            auth: false
        }
    },
    {
        method: 'GET',
        path: '/getInfos',
        handler: 'documentation.getInfos',
        config: {
            policies: [
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'plugin::documentation.read'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'POST',
        path: '/regenerateDoc',
        handler: 'documentation.regenerateDoc',
        config: {
            policies: [
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'plugin::documentation.settings.regenerate'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'PUT',
        path: '/updateSettings',
        handler: 'documentation.updateSettings',
        config: {
            policies: [
                {
                    name: 'admin::hasPermissions',
                    config: {
                        actions: [
                            'plugin::documentation.settings.update'
                        ]
                    }
                }
            ]
        }
    },
    {
        method: 'DELETE',
        path: '/deleteDoc/:version',
        handler: 'documentation.deleteDoc',
        config: {
            policies: []
        }
    }
];

const validation = {
    validateSettings: validateYupSchema(yup.object().shape({
        restrictedAccess: yup.boolean(),
        password: yup.string().min(8).matches(/[a-z]/, '${path} must contain at least one lowercase character').matches(/[A-Z]/, '${path} must contain at least one uppercase character').matches(/\d/, '${path} must contain at least one number').when('restrictedAccess', (value, initSchema)=>{
            return value ? initSchema.required('password is required') : initSchema;
        })
    }))
};
var documentation = {
    async getInfos (ctx) {
        try {
            const docService = getService('documentation');
            const docVersions = docService.getDocumentationVersions();
            const documentationAccess = await docService.getDocumentationAccess();
            ctx.send({
                docVersions,
                currentVersion: docService.getDocumentationVersion(),
                prefix: '/documentation',
                documentationAccess
            });
        } catch (err) {
            strapi.log.error(err);
            ctx.badRequest();
        }
    },
    async index (ctx, next) {
        try {
            /**
       * We don't expose the specs using koa-static or something else due to security reasons.
       * That's why, we need to read the file localy and send the specs through it when we serve the Swagger UI.
       */ const { major, minor, patch } = ctx.params;
            const version = major && minor && patch ? `${major}.${minor}.${patch}` : getService('documentation').getDocumentationVersion();
            const openAPISpecsPath = path.join(strapi.dirs.app.extensions, 'documentation', 'documentation', version, 'full_documentation.json');
            try {
                const documentation = fs.readFileSync(openAPISpecsPath, 'utf8');
                const layout = (await import('./chunks/index-Dz3orHaf.mjs')).default;
                const filledLayout = _.template(layout)({
                    backendUrl: strapi.config.server.url,
                    spec: JSON.stringify(JSON.parse(documentation))
                });
                try {
                    const layoutPath = path.resolve(strapi.dirs.app.extensions, 'documentation', 'public', 'index.html');
                    await fs.ensureFile(layoutPath);
                    await fs.writeFile(layoutPath, filledLayout);
                    // Serve the file.
                    ctx.url = path.basename(`${ctx.url}/index.html`);
                    try {
                        const staticFolder = path.resolve(strapi.dirs.app.extensions, 'documentation', 'public');
                        return koaStatic(staticFolder)(ctx, next);
                    } catch (e) {
                        strapi.log.error(e);
                    }
                } catch (e) {
                    strapi.log.error(e);
                }
            } catch (e) {
                strapi.log.error(e);
            }
        } catch (e) {
            strapi.log.error(e);
        }
    },
    async loginView (ctx, next) {
        // lazy require cheerio
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const cheerio = require('cheerio');
        const { error } = ctx.query;
        try {
            const layout = (await import('./chunks/login-CYdORE5u.mjs')).default;
            const filledLayout = _.template(layout.toString())({
                actionUrl: `${strapi.config.server.url}/documentation/login`
            });
            const $ = cheerio.load(filledLayout);
            $('.error').text(_.isEmpty(error) ? '' : 'Wrong password...');
            try {
                const layoutPath = path.resolve(strapi.dirs.app.extensions, 'documentation', 'public', 'login.html');
                await fs.ensureFile(layoutPath);
                await fs.writeFile(layoutPath, $.html());
                ctx.url = path.basename(`${ctx.url}/login.html`);
                try {
                    const staticFolder = path.resolve(strapi.dirs.app.extensions, 'documentation', 'public');
                    return koaStatic(staticFolder)(ctx, next);
                } catch (e) {
                    strapi.log.error(e);
                }
            } catch (e) {
                strapi.log.error(e);
            }
        } catch (e) {
            strapi.log.error(e);
        }
    },
    async login (ctx) {
        const { body: { password } } = ctx.request;
        const { password: hash } = await strapi.store({
            type: 'plugin',
            name: 'documentation',
            key: 'config'
        }).get();
        const isValid = await bcrypt.compare(password, hash);
        let querystring = '?error=password';
        if (isValid && ctx.session) {
            ctx.session.documentation = {
                logged: true
            };
            querystring = '';
        }
        ctx.redirect(`${strapi.config.server.url}/documentation${querystring}`);
    },
    async regenerateDoc (ctx) {
        const { version } = ctx.request.body;
        const service = getService('documentation');
        const documentationVersions = service.getDocumentationVersions().map((el)=>el.version);
        if (_.isEmpty(version)) {
            return ctx.badRequest('Please provide a version.');
        }
        if (!documentationVersions.includes(version)) {
            return ctx.badRequest('The version you are trying to generate does not exist.');
        }
        try {
            strapi.reload.isWatching = false;
            await service.generateFullDoc(version);
            ctx.send({
                ok: true
            });
        } finally{
            strapi.reload.isWatching = true;
        }
    },
    async deleteDoc (ctx) {
        const { version } = ctx.params;
        const service = getService('documentation');
        const documentationVersions = service.getDocumentationVersions().map((el)=>el.version);
        if (_.isEmpty(version)) {
            return ctx.badRequest('Please provide a version.');
        }
        if (!documentationVersions.includes(version)) {
            return ctx.badRequest('The version you are trying to delete does not exist.');
        }
        try {
            strapi.reload.isWatching = false;
            await service.deleteDocumentation(version);
            ctx.send({
                ok: true
            });
        } finally{
            strapi.reload.isWatching = true;
        }
    },
    async updateSettings (ctx) {
        const pluginStore = strapi.store({
            type: 'plugin',
            name: 'documentation'
        });
        const data = await validation.validateSettings(ctx.request.body);
        const config = {
            restrictedAccess: Boolean(data.restrictedAccess)
        };
        if (data.password) {
            config.password = await bcrypt.hash(data.password, 10);
        }
        await pluginStore.set({
            key: 'config',
            value: config
        });
        return ctx.send({
            ok: true
        });
    }
};

var controllers = {
    documentation
};

const defaultConfig = {
    openapi: '3.0.0',
    info: {
        version: '1.0.0',
        title: 'DOCUMENTATION',
        description: '',
        termsOfService: 'YOUR_TERMS_OF_SERVICE_URL',
        contact: {
            name: 'TEAM',
            email: 'contact-email@something.io',
            url: 'mywebsite.io'
        },
        license: {
            name: 'Apache 2.0',
            url: 'https://www.apache.org/licenses/LICENSE-2.0.html'
        }
    },
    'x-strapi-config': {
        plugins: null,
        mutateDocumentation: null
    },
    servers: [],
    externalDocs: {
        description: 'Find out more',
        url: 'https://docs.strapi.io/developer-docs/latest/getting-started/introduction.html'
    },
    security: [
        {
            bearerAuth: []
        }
    ],
    paths: {},
    components: {
        securitySchemes: {
            bearerAuth: {
                type: 'http',
                scheme: 'bearer',
                bearerFormat: 'JWT'
            }
        },
        schemas: {
            Error: {
                type: 'object',
                required: [
                    'error'
                ],
                properties: {
                    data: {
                        nullable: true,
                        oneOf: [
                            {
                                type: 'object'
                            },
                            {
                                type: 'array',
                                items: {
                                    type: 'object'
                                }
                            }
                        ]
                    },
                    error: {
                        type: 'object',
                        properties: {
                            status: {
                                type: 'integer'
                            },
                            name: {
                                type: 'string'
                            },
                            message: {
                                type: 'string'
                            },
                            details: {
                                type: 'object'
                            }
                        }
                    }
                }
            }
        }
    }
};

const config = {
    default: defaultConfig
};

var index = {
    bootstrap,
    config,
    routes,
    controllers,
    register,
    services
};

export { index as default };
//# sourceMappingURL=index.mjs.map
